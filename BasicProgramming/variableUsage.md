# 변수와 상수의 사용 

## 변수

컴퓨터 프로그램에서 변수는 컴퓨터 프로그램에서 처리하는 데이터와 관련이 있는 것으로 데이터를 저장할 수 있는 저장 공간(메모리의 저장공간)을 뜻한다. 
프로그램이 실행 중에 변수의 저장공간에 저장된 값은 변경이 가능하다. 일반 변수의 경우는 변수 이름으로 저장공간에 저장된 데이터 값을 참조할 수 있다. 
일반적으로 컴퓨터 프로그램에서는 프로그램에서 처리하는 데이터의 개수만큼 저장공간이 필요한 경우 그 수 만큼 변수가 필요하다. 또한 처리하는 데이터 형태에 따라 
적합한 변수가 요구된다. 프로그램 실행 중에 데이터를 저장할 저장공간을 할당은 다음에 논의할 ```변수 선언```을 통해서 행한다. 

### 변수 이름 만들기

모든 변수들은 이름을 가진다. 변수의 이름은 프로그래머가 만들어야 하기 때문에 변수를 만드는 규칙을 이해하는 것이 필요하다. 또한 다른 저장공간을 할당하는 변수의
이름은 서로 달라야 한다. 하나의 프로그램에서 동일한 이름을 가진 변수가 여럿 존재할 수 없다. 변수 이름은 필요에 따라 결정하는데 변수 이름을 통해 어떠한 데이터가
저장되는지를 알 수 있도록 만드는 것이 좋다. 이름을 저장하는 변수 이름을 결정하려고 하는데 ```num```이라는 변수 이름을 사용하는 것은 본인 뿐만 아니라 
공동 개발자들에게 혼돈을 줄 수 있으므로 하지 않는 것이 좋다. 즉, 변수의 이름은 변수의 이름으로 저장공간에 저장되 데이터의 의미를 추론할 수 있도록 만든 것이 좋다.

변수 이름은 식별자(identifier)라고 하며 식별자가 되기 위해서는 다음과 같은 규칙을 따라야 한다. 

* 숫자로 시작하는 변수 이름은 사용할 수 없다. 
* 알파벳 대문자와 소문자는 다른 문자를 구분한다. (그러나 혼동을 피하기 위해 동일한 이름을 대소문자로 구변하지 않도록 한다.)
* 변수 이름의 길이는 제한이 없다. (개발 환경에 따라 식별자의 길이가 31자로 제한되는 경우도 있다.)
* C++가 예약한 키워드(keyword)는 사용할 수 없다. (키워드의 예: main, class, struct, return)
* 언더바(_)를 제외한 특수문자는 사용이 불가능하다. 
* 영문자, 숫자, 그리고 한글도 가능하고 사용이 가능하다.

### 변수 명명법

최근 소프트웨어 개발 시 여러 개발자가 협업을 하여야 하는 경우가 많다. 하나의 프로젝트에서 모두 동알한 규약으로 변수 이름을 만들도록 하여 코드의 가독성을 
높일 수 있도록 한다. 대표적인 변수 이름 규약은 다음이 있다.

* Camel Casing (카멜표기법)
  + 각 단어의 첫문자를 대문자로 표기하고 붙여쓰는 표기법으로 맨 처음 문자는 소문자로 표기
    - 예) utilityBox, mainFrame, personState
* Pascal Casing (파스칼표기법)
  + 변수 이름의 시작을 대문자로 표기하고 복합어인 경우 중간에 시작하는 새로운 단어의 첫 단어도 대문자로 표기 
  + 카멜표기법과 유사
    - 예) UtilityBox, MainFraome, PersonState
* Hungarian notiation (헝가리안 표기법)
  + 마이크로소프트 개발장 중 헝기리 프로그래머인 찰스 시모니(Charles Simonyi)가 쓰던 변수 이름 규정으로 마이크로소프트 내부에서 사용되던 표기법
  + 최근들어 IDE의 발달로 변수에 커서만 가져가면 해당 변수의 각종 정보를 보여주는 기능을 지원하여 지금은 마이크로소프트도 공식 가이드라인에서 사용하지 말 것을 권고
    - 예) int자료형 + apple -> intApple 
* GNU 이름 규칙
  + 모두 소문자를 사용하고 복합어 사이를 '_'를 사용하여 연결한다.
    - 예) gtk_widget_activate

## 변수 선언 

프로그램에서 데이터를 처리하기 위해서 데이터를 저장할 저장공간이 요구된다. 즉 변수를 사용하기 위해서는 
저장공간이 할당(변수 선언)이 필요하다. 저장공간을 할당하는 과정은 다음 형식을 따른다.

```<자료형> <변수이름1>, <변수이름2>, <변수이름3>;```

예로 전구의 밝기를 제어하는 프로그램을 작성하고자 한다. 전구의 밝기가 0 ~ 255 까지 정수 값으로 제어하는 프로그램에서 
밝기를 저장하는 변수 ```bulbBrightness``` 를 선언하고자 한다. 최소의 저장공간을 할당하는 자료형으로 선언하는 것은 다음과 같다.

```unsigned char bulbBrightness;        // 변수 bulbBrightness 선언```

앞과 같이 ```bulbBrightness``` 변수를 선언하면 1바이트의 저장공간이 할당된다. 할당된 저장공간에는 임의의(random) 값이 저장된다. 
변수의 선언은 저장공간을 활용하기 전 (변수에 데이터 값의 저장, 데이터 값의 변경 등 데이터를 처리하기 전)에 이루어지기만 하면된다.

변수 선언문에 같은 자료형의 저장공간 여러 개를 동시에 선언할 수 있다.

```unsigned char bulbBrightness, doorBulbBrightness; ```

### 변수 초기화

변수 선언과 함께 변수(저장공간)에 원하는 값을 저장할 수 있다. 이를 **변수 초기화** 라고 한다. 
C++에서는 세 가지 방법이 사용된다. 

첫번쨰는 **대입연산자 (=)** 를 이용하는 것으로 **복사 초기화**이다.  
대입연산자의 의미는 오른쪽의 값을 왼쪽의 변수에 저장하라는 뜻이다.
대입연산자를 적용할 때 기본적으로 왼쪽 데이터의 형태와 오론쪽 데이터 형태가 같아야 한다. 

변수에 데이터를 저장하기 위해서  
앞의 변수 ```bulbBrightness```를 선언할 때 대입연산자를 사용하여 저장공간에 100을 저장하는(초기화) 코드는 다음과 같다.

```unsighed char bulbBrightness = 100; // 변수 bulbBrightness 선언과 동시에 저장 값 초기화 ```

두번쨰는 소괄호 ()를 사용하여 직접 초기화하는 방법이다. **직접 초기화**는 일부 데이터 형태에서 복사 초기화 보다 성능이 더 뛰어날 수 있다.
대입연산자를 이용한 초기화를 직접 초기화를 통한 초기화 코드는 다음과 같다.

```unsigned char bulbBrightness(100);```

앞의 복사 초기화와 직접 초기화는 일부 데이터 자료형의 변수에 대해서만 동작한다. 모든 데이터 자료형에서 동작하는 일관된 초기화 메커니즘을 제공하기 위해
C++ 11에서 **유니폼 초기화(uniform initializaion)** 라는 새로운 초기화 메커니즘을 추가했다. 
유니폼 초기화로 초기화하는 코드는 다음과 같다. 

```unsigned char bulbBrightness {100}```


## 변수에 데이터 대입하기 

변수에 값을 저장하는 연산자는 **대임연산자(assignment operator)** 이다. 앞에서 변수 초기화에서 보았듯이 대입연산자는 등호(=)이다. 
대입연산자의 의미는 오른쪽의 값을 왼쪽의 변수에 저장하라는 뜻이다. 대입연산자를 적용할 때 기본적으로 왼쪽 데이터의 형태와 오론쪽 데이터 형태가 같아야 한다. 

다음 코드 ```variable = data;```는 왼쪽의 variable은 이미 선언한 변수에 해당되고 오른쪽의 data로는 실제 대이터 값 (리터럴 데이터: literal data), 변수, 수식이 될 수 있다.

* 변수에 리터럴 데이터를 대입하는 예는 다음과 같다.  
```C++
programScore = 'A';   // 문자 자장 
myHeight = 175.3;     // 실수 저장 
carQuantity = 4;      // 정수 저장
velocity = 2.99792E+8;    // 실수 저장
```

* 다음은 변수에 리터럴 데이터의 연산 결과, 저장된 값의 대입, 변수와 리터럴 데이터와의 연산 결과를 대입하는 예는 다음과 같다.

```C++
finalScore = programScore;  
circleArea = 3.14 * circleRadius * cricleRadius;
rectArea = rectHeight * rectWidth;
salePrice = 10 * 0.6; 
```

## 상수 선언 

상수는 앞에서 설명하였듯이 메모리의 저장공간에 저장된 값을 변경하지 못하는 저장공간을 뜻한다. C++에서 두 가지 의미의 불변성(immutability)을 제공힌다.

그중 하나가 ```const``` 키워드이다. ```const```는 "이 값을 변경하지 않는다는 약속"의 의미로 함수에 데이터를 포인터나 레퍼런스 형태로 전달할 때 데이터 
값을 변경하지 않는다는 것을 인터페이스에 명시하길 원할 때 사용한다. 컴파일러는 ```const``` 로 명시된 약속을 지키도록 강제하지만 ```const``` 값은 실행시간에
계산될 수 있다. 

다른 하나는 ```constexpr```로 "이 값은 컴파일 시간에 평가한다"는 의미로 주로 해당 데이터를 상수로 지정하여 읽기 전용 메모리에 저장한다. ```constexpr```은
반드시 컴파일 시간에 계산된다. 

변수를 상수로 설졍하는 것은 변수의 자료형 앞이나 다음에 ```const``` 키워드를 사용하면 된다. 

```C++
const double gravity {9.8};   // const 키워드를 자료형 앞에 두는 것이 관행
int const sidesInSqure {4};
```
변수를 상수로 설정하는 경우 선언할 때 초기화하여야 하며 선언 후 변수처럼 대입연산자로 값을 변경할 수 없다. 



### 상수에 데이터 대입하기
